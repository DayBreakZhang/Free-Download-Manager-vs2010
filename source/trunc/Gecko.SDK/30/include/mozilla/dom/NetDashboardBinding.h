/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#ifndef mozilla_dom_NetDashboardBinding_h__
#define mozilla_dom_NetDashboardBinding_h__

#include "js/RootingAPI.h"
#include "jspubtd.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/Nullable.h"

namespace mozilla {
namespace dom {

struct ConnStatusDictAtoms;
struct DNSCacheDictAtoms;
struct DNSLookupDictAtoms;
struct DnsCacheEntry;
struct DnsCacheEntryAtoms;
struct HalfOpenInfoDict;
struct HalfOpenInfoDictAtoms;
struct HttpConnDictAtoms;
struct HttpConnInfo;
struct HttpConnInfoAtoms;
struct HttpConnectionElement;
struct HttpConnectionElementAtoms;
class NativePropertyHooks;
class ProtoAndIfaceArray;
struct SocketElement;
struct SocketElementAtoms;
struct SocketsDictAtoms;
struct WebSocketDictAtoms;
struct WebSocketElement;
struct WebSocketElementAtoms;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

struct ConnStatusDict : public DictionaryBase
{
  nsString mStatus;

  ConnStatusDict();

  explicit inline ConnStatusDict(const ConnStatusDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline ConnStatusDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, ConnStatusDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const ConnStatusDict& aOther);
};

namespace binding_detail {
struct FastConnStatusDict : public ConnStatusDict
{
  inline FastConnStatusDict()
    : ConnStatusDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DNSLookupDict : public DictionaryBase
{
  Optional<Sequence<nsString > > mAddress;
  bool mAnswer;
  nsString mError;

  DNSLookupDict();

  explicit inline DNSLookupDict(const DNSLookupDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline DNSLookupDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, DNSLookupDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const DNSLookupDict& aOther);
};

namespace binding_detail {
struct FastDNSLookupDict : public DNSLookupDict
{
  inline FastDNSLookupDict()
    : DNSLookupDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DnsCacheEntry : public DictionaryBase
{
  double mExpiration;
  nsString mFamily;
  Optional<Sequence<nsString > > mHostaddr;
  nsString mHostname;

  DnsCacheEntry();

  explicit inline DnsCacheEntry(const DnsCacheEntry& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline DnsCacheEntry(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, DnsCacheEntryAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const DnsCacheEntry& aOther);
};

namespace binding_detail {
struct FastDnsCacheEntry : public DnsCacheEntry
{
  inline FastDnsCacheEntry()
    : DnsCacheEntry(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HalfOpenInfoDict : public DictionaryBase
{
  bool mSpeculative;

  HalfOpenInfoDict();

  explicit inline HalfOpenInfoDict(const HalfOpenInfoDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline HalfOpenInfoDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, HalfOpenInfoDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const HalfOpenInfoDict& aOther);
};

namespace binding_detail {
struct FastHalfOpenInfoDict : public HalfOpenInfoDict
{
  inline FastHalfOpenInfoDict()
    : HalfOpenInfoDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HttpConnInfo : public DictionaryBase
{
  nsString mProtocolVersion;
  uint32_t mRtt;
  uint32_t mTtl;

  HttpConnInfo();

  explicit inline HttpConnInfo(const HttpConnInfo& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline HttpConnInfo(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, HttpConnInfoAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const HttpConnInfo& aOther);
};

namespace binding_detail {
struct FastHttpConnInfo : public HttpConnInfo
{
  inline FastHttpConnInfo()
    : HttpConnInfo(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SocketElement : public DictionaryBase
{
  bool mActive;
  nsString mHost;
  uint32_t mPort;
  double mReceived;
  double mSent;
  bool mTcp;

  SocketElement();

  explicit inline SocketElement(const SocketElement& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline SocketElement(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, SocketElementAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const SocketElement& aOther);
};

namespace binding_detail {
struct FastSocketElement : public SocketElement
{
  inline FastSocketElement()
    : SocketElement(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct WebSocketElement : public DictionaryBase
{
  bool mEncrypted;
  nsString mHostport;
  uint32_t mMsgreceived;
  uint32_t mMsgsent;
  double mReceivedsize;
  double mSentsize;

  WebSocketElement();

  explicit inline WebSocketElement(const WebSocketElement& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline WebSocketElement(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, WebSocketElementAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const WebSocketElement& aOther);
};

namespace binding_detail {
struct FastWebSocketElement : public WebSocketElement
{
  inline FastWebSocketElement()
    : WebSocketElement(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DNSCacheDict : public DictionaryBase
{
  Optional<Sequence<DnsCacheEntry > > mEntries;

  DNSCacheDict();

  explicit inline DNSCacheDict(const DNSCacheDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline DNSCacheDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, DNSCacheDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const DNSCacheDict& aOther);
};

namespace binding_detail {
struct FastDNSCacheDict : public DNSCacheDict
{
  inline FastDNSCacheDict()
    : DNSCacheDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HttpConnectionElement : public DictionaryBase
{
  Optional<Sequence<HttpConnInfo > > mActive;
  Optional<Sequence<HalfOpenInfoDict > > mHalfOpens;
  nsString mHost;
  Optional<Sequence<HttpConnInfo > > mIdle;
  uint32_t mPort;
  bool mSpdy;
  bool mSsl;

  HttpConnectionElement();

  explicit inline HttpConnectionElement(const HttpConnectionElement& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline HttpConnectionElement(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, HttpConnectionElementAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const HttpConnectionElement& aOther);
};

namespace binding_detail {
struct FastHttpConnectionElement : public HttpConnectionElement
{
  inline FastHttpConnectionElement()
    : HttpConnectionElement(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SocketsDict : public DictionaryBase
{
  double mReceived;
  double mSent;
  Optional<Sequence<SocketElement > > mSockets;

  SocketsDict();

  explicit inline SocketsDict(const SocketsDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline SocketsDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, SocketsDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const SocketsDict& aOther);
};

namespace binding_detail {
struct FastSocketsDict : public SocketsDict
{
  inline FastSocketsDict()
    : SocketsDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct WebSocketDict : public DictionaryBase
{
  Optional<Sequence<WebSocketElement > > mWebsockets;

  WebSocketDict();

  explicit inline WebSocketDict(const WebSocketDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline WebSocketDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, WebSocketDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const WebSocketDict& aOther);
};

namespace binding_detail {
struct FastWebSocketDict : public WebSocketDict
{
  inline FastWebSocketDict()
    : WebSocketDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HttpConnDict : public DictionaryBase
{
  Optional<Sequence<HttpConnectionElement > > mConnections;

  HttpConnDict();

  explicit inline HttpConnDict(const HttpConnDict& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline HttpConnDict(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, HttpConnDictAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const HttpConnDict& aOther);
};

namespace binding_detail {
struct FastHttpConnDict : public HttpConnDict
{
  inline FastHttpConnDict()
    : HttpConnDict(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_NetDashboardBinding_h__
